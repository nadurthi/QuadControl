







#ifndef _KINEMATIC_ESTIMATORS_H_
#define _KINEMATIC_ESTIMATORS_H_



#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <sys/types.h>
#include <fstream>
#include <cmath>
#include "quaternion_operations.h"
#include <algorithm>
using namespace std;



#define data_queue_length 10  //no. of time steps of data to remember( so it can be used for simple moving average filters)




class SimpleQueue {
	double  **a,*stdev,*maxstdev;
	int rows,columns;

public:
	//dynamically create a Queue and initialize with zeros
	void CreateQ(int rows,int cols){
		this->rows=rows;
		columns=cols;
		// allocation
		 stdev=new double [cols];
		 maxstdev=new double [cols];

			a = new double*[rows];
			for(int i = 0; i < rows; i++)
				a[i] = new double[cols];

			for(int r=0;r<rows;r++){
				for(int c=0;c<cols;c++){
					a[r][c]=0;
				}
			}
	}

	int * GetSizeQ(int *S){
		S[0]=rows;S[1]=columns;
		return S;
	}
    int CheckSizeQ(int r,int c){
    	if((r<rows && r>=0) && (c<columns && c>=0))
    	return 1;
    	else
    	return -1;
    }

	//append always to the last of queue. D has same columns as Q. The ques is shifted up. First element is lost
    void AppendQ(double *D);
    // replace the (r-1)th row...as counting starts from 0
    void ReplaceRowQ(int r,double *D);
    void ReplaceLastRowQ(double *D);

    //Operations along the rows. Each Col is independednt. From row r1 to r2
    // rmemeber r1 and r2 are c++ ref not matlab ref. ie.e counting starts from 0 in c++.
    //if u want  from 5th row to 9th row, r1=4,r2=8; rows r1 and r2 are also included in the calculation
    double * MeanQ(double * D, int r1, int r2) ;
    double * VarQ(double * D, int r1, int r2) ;
    double * StdQ(double * D, int r1, int r2) ;

    //get the data out
    double * GetRowQ(int r,double *D);
    double * GetColQ(int c,double *D);
    double * GetLastRowQ(double *D);

};




 //%%%%%%%%%%%%%%%%%%%%%%%   States used in your estimator/controller   %%%%%%%%%%%%%%%%%%%%%%
struct QuadStateVariable {
	 double t;
	 SimpleQueue tvec;

	 double q[4],w[3],x[3],v[3],a[3],wdot[3]; //all the current filtered estimated quantities
	 double w_meas[3],a_meas[3],x_meas[3],q_meas[4]; //stores the history of IMU measurements

	 // raw data with not conditioning or estimation
	 //double Data_w_meas[3][data_queue_length],Data_a_meas[3][data_queue_length],Data_q_meas[4][data_queue_length],Data_x_meas[3][data_queue_length];
	 SimpleQueue Data_w_meas,Data_a_meas,Data_q_meas,Data_x_meas;

	 // filtered data after conditions and estimation
	 //double Data_w_est[3][data_queue_length],Data_a_est[3][data_queue_length],Data_q_est[4][data_queue_length],Data_x_est[3][data_queue_length];
	 //double Data_v_est[3][data_queue_length],Data_wdot_est[3][data_queue_length];
	 SimpleQueue Data_w_est,Data_a_est,Data_q_est,Data_x_est,Data_v_est,Data_wdot_est;


	 double Fd[3]; //latest force thrust required

	 double ba[3],bg[3],rmis[3],qmis[4];//all the constant est parameters

	 // the std deviatins required for outlier detection q[4][3]=[q0,q1,q2,q3][maxstd,meanstd,curr_std]
	 double Maxstd_q[4][3],Maxstd_w[3][3],Maxstd_a[3][3],Maxstd_x[3][3],Maxstd_v[3][3],Maxstd_wdot[3][3];
};
 //*******************************************************************************************



/*
 * Queue Outlier remover Function: Filters the last entry of a queue
 */





/*
 * Function to first condition the data (remove outlier data). Check for physical consistency
 * for all the variables (because sometimes data from serial can be erratic). if there is an outlier
 * just use previous value or avg value
 */
void Condition_latest_data_Algo1(QuadStateVariable * data);








// Filter 1:   Onboard attitude estimator : estimates q and w.  (quaternion and body rates)
// Primary input are acc and gyro measurements
// secondary inputs are external vicon x and q. (this comes at a slower rate).
// Additionally the biases can be estimated onboard or on ground station.
// Have to send the imu data back to ground station at the same rate as vicon input.
// REMEMBER: the acc measurements actually measure the gravity force also. so always remove the gravity force to get true acc values

//**************************************** Method 1a: onboard bias correction ******************************************************





//**************************************** Method 1b: use ground station bias correction ******************************************************
//FUTURE: Correct IMU q misalignment wrt to vicon q







//Filter 2: Onboard attitude estimator
// Primary input are acc and gyro measurements
// No secondary vicon input
// biases are to be corrected with onboard imu data itself(perhaps at time 0)
// REMEMBER: the acc measurements actually measure the gravity force also. so always remove the gravity force to get true acc values


















#endif
