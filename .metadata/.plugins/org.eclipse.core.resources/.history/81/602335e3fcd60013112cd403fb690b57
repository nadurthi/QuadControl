
#include <iostream>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>
#include <stropts.h>
#include <cmath>
#include <stdio.h>
#include <string>
#include <sys/types.h>
#include <time.h>
#include <sys/time.h>
#include <stdint.h>
#include <fstream>
#include <cmath>
#include "pwm_4motor.h"
#include "/home/nagnanamus/Dropbox/BBB/codes/quad_control/working_source_codes/Eigen/Dense"
#include "matrix_operations.h"

#include "controllers.h"

#include "SimpleTimer.h"

using namespace std;



#include "SerialcommGroundOnboard.h"
#include "kinematic_estimators.h"
#include "State_data_manager.h"


#include "I2Cdev.h"
#include "MPU6050.h"

MPU6050 AccelGyroSensor;

QuadStateVariable QuadState;

Serial_comm_Ground_Onboard GroundComm;

//EKF_Estimator_onboard1 OnbaordEstimator;
EKF_Estimator1 OnbaordEstimator;

SimpleTimer OnboardTimer,TicToc;

PWMmotors Motorpwms;


int main() {



//Setup motor pwm control
	Motorpwms.set_max_min_force(0,50);   //#######   SET the MAX FORCE HERE  ##########################
	Motorpwms.init_escs();



//Setup the communication with ground station
GroundComm.Init_as_Onboard();



//set the state variables
QuadState.Init_SetZero();

// Initialize the estimator
	OnbaordEstimator.InitializeFilter();
	cout<<"Done initiating the Estimator"<<endl;


/*
 *  set the limits for received data and all the other data
 */
	QuadState.Fdnorm_limit=20;
	QuadState.Fsafety=20;
	QuadState.ulim=10;  //in Newtons
	QuadState.ba_lim=2;  // m/s^2
	QuadState.bg_lim=2;  // rad/s
	QuadState.rmis_lim=0.05; // m
	QuadState.kx=1;
	QuadState.kv=1;
	QuadState.kq=1;
	QuadState.kw=1;
	QuadState.aref[0]=0;	QuadState.aref[1]=0;	QuadState.aref[2]=0;
	QuadState.vref[0]=0;	QuadState.vref[1]=0;	QuadState.vref[2]=0;
	QuadState.xref[0]=0;	QuadState.xref[1]=0;	QuadState.xref[2]=0;
	QuadState.qref[0]=1;	QuadState.qref[1]=0;	QuadState.qref[2]=0;	QuadState.qref[3]=0;
	QuadState.wref[0]=0;	QuadState.wref[1]=0;	QuadState.wref[2]=0;
	QuadState.b1ref[0]=0;	QuadState.b1ref[1]=0;	QuadState.b1ref[2]=0;

	QuadState.rmis[0]=-0.004;QuadState.rmis[1]=0.013;QuadState.rmis[2]=-0.025;
	QuadState.qmis[0]=1;QuadState.qmis[1]=0;QuadState.qmis[2]=0;QuadState.qmis[3]=0;




//initialize the imu
AccelGyroSensor.initialize();



SimpleQueue ViconInitQ,IMUInitQ;
ViconInitQ.CreateQ(200,7);
IMUInitQ.CreateQ(200,6);

//Setup the timer
OnboardTimer.SetTsec(0.01);

/*
 *  Get the biases and stationary values like.. maxdevs
 */
double DataVicon[8],Data_imu[7];
int n;
for( n=0;n<200;n++){
	OnboardTimer.ResetTimer();

			while(GroundComm.Checkif_DataPresent_onboard(8)<=0){}

			GroundComm.Onboard_SimpleRecieve(0,&QuadState,DataVicon);

			AccelGyroSensor.getScaledaccgyro_timestamped(Data_imu);
			QuadState.Update_AccelGyro_meas(Data_imu,0);

					ViconInitQ.SeriesFillQ(DataVicon+1);
					IMUInitQ.SeriesFillQ(Data_imu+1);

					cout<<"n = "<<n<<endl;
					cout<<Data_imu[0]<<"   "<<DataVicon[0]<<endl;

			while(OnboardTimer.CheckTimer()){}
		}

//first estimate the stationary q values, maxdev for vicon
	Initialize_QX_ground(&QuadState,&ViconInitQ);
//use the above estimated q to find ba,bg, maxdstdev
	Initialize_IMU_ground(&QuadState,&IMUInitQ);
// Destroy the useless queues
	ViconInitQ.DestroyQ();
	IMUInitQ.DestroyQ();

// Corrector filter maxstdevs
			QuadState.Data_x_meas.maxstdev[0]=1;
			QuadState.Data_x_meas.maxstdev[1]=1;
			QuadState.Data_x_meas.maxstdev[2]=1;

			QuadState.Data_q_meas.maxstdev[0]=1;
			QuadState.Data_q_meas.maxstdev[1]=1;
			QuadState.Data_q_meas.maxstdev[2]=1;
			QuadState.Data_q_meas.maxstdev[3]=1;

			QuadState.Data_a_meas.maxstdev[0]=1;
			QuadState.Data_a_meas.maxstdev[1]=1;
			QuadState.Data_a_meas.maxstdev[2]=1;

			QuadState.Data_w_meas.maxstdev[0]=1;
			QuadState.Data_w_meas.maxstdev[1]=1;
			QuadState.Data_w_meas.maxstdev[2]=1;


QuadState.PrintStates();
QuadState.Record2file(Data_imu,DataVicon);


cout<<"done evaluating the stat paras"<<endl;


cout<<"entering eternal loop..... Hit ENTER to begin"<<endl;
cin>>n;

    while(1){
    	OnboardTimer.ResetTimer();

    				if(GroundComm.Checkif_DataPresent_onboard(8)>0){
    					cout<<"###################################   GROUND DATA ###############################"<<endl;
    							//Reset the emergency controller shutdown timer
    							QuadState.EmergencyShutoff.ResetTimer();


    							GroundComm.Onboard_SimpleRecieve(1,&QuadState,DataVicon);

    				}

            // Update IMU measurement
    				AccelGyroSensor.getScaledaccgyro_timestamped(Data_imu);
    				QuadState.Update_AccelGyro_meas(Data_imu,1);
    				QuadState.IMUupdateFLAG=1;
    				cout<<"getting imu data at t = "<<Data_imu[0]<<endl;


        	//Estimate the required quatities
    				OnbaordEstimator.PropagateUpdateMeanCov(&QuadState);

            //Printing to screen
    				//OnbaordEstimator.PrintFiltervals();


        	//Compute the control
    				//TicToc.ResetTimer();
    				ComputeControl_att(&QuadState);
    				//cout<<"Controller Latency = "<<TicToc.GetTime_from_T0sec()<<endl;

           	///////////////  Emergency Shutoff check  ////////////////////////////
    				QuadState.CheckEmergency_shutoff();

        	//Apply the updated control
    				Motorpwms.set_pwms(&QuadState);

    		//Recording data
    				QuadState.Record2file(Data_imu,DataVicon);
    				Data_imu[0]=nan;Data_imu[1]=nan;Data_imu[2]=nan;Data_imu[3]=nan;Data_imu[4]=nan;Data_imu[5]=nan;Data_imu[6]=nan;
    				DataVicon[0]=nan;DataVicon[1]=nan;DataVicon[2]=nan;DataVicon[3]=nan;DataVicon[4]=nan;DataVicon[5]=nan;DataVicon[6]=nan;DataVicon[7]=nan;


    	while(OnboardTimer.CheckTimer()){usleep(1000);}

    } //while eternal

    return 1;
}
