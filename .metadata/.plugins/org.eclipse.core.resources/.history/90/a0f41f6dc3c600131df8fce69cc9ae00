







#ifndef _KINEMATIC_ESTIMATORS_H_
#define _KINEMATIC_ESTIMATORS_H_



#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <sys/types.h>
#include <fstream>
#include <cmath>
#include "quaternion_operations.h"
#include <algorithm>
#include "/home/nagnanamus/Dropbox/BBB/codes/quad_control/working_source_codes/Eigen/Dense"
using namespace std;

using Eigen::MatrixXd;

#define data_queue_length 10  //no. of time steps of data to remember( so it can be used for simple moving average filters)




class SimpleQueue {
	double  **a,*stdev,*maxstdev,*mu;
	int rows,columns;

public:
	//dynamically create a Queue and initialize with zeros
	void CreateQ(int rows,int cols){
		this->rows=rows;
		columns=cols;
		// allocation
		 stdev=new double [cols];
		 maxstdev=new double [cols];
		 mu=new double [cols];

			a = new double*[rows];
			for(int i = 0; i < rows; i++)
				a[i] = new double[cols];

			for(int r=0;r<rows;r++){
				for(int c=0;c<cols;c++){
					a[r][c]=0;
					stdev[c]=0;
					maxstdev[c]=0;
				}
			}
	}

	int * GetSizeQ(int *S){
		S[0]=rows;S[1]=columns;
		return S;
	}
    int CheckSizeQ(int r,int c){
    	if((r<rows && r>=0) && (c<columns && c>=0))
    	return 1;
    	else
    	return -1;
    }

	//append always to the last of queue. D has same columns as Q. The ques is shifted up. First element is lost
    //C is array of column numbers of D to be used
    void AppendQ(double *D,int *C);
    // replace the (r-1)th row...as counting starts from 0
    void ReplaceRowQ(int r,double *D);
    void ReplaceLastRowQ(double *D);

    //Operations along the rows. Each Col is independednt. From row r1 to r2
    // rmemeber r1 and r2 are c++ ref not matlab ref. ie.e counting starts from 0 in c++.
    //if u want  from 5th row to 9th row, r1=4,r2=8; rows r1 and r2 are also included in the calculation
    void MeanQ(int r1, int r2) ;
    void StdQ( int r1, int r2) ; // also updates the corresponding mu

    //get the data out
    double * GetRowQ(int r,double *D);
    double * GetColQ(int c,double *D);
    double * GetLastRowQ(double *D);
    double * GetStdQ(double *D){
    	for(int i=0;i<columns;i++)
    		D[i]=stdev[i];

    	return D;
    }
    double * GetVarQ(double *D){
        	for(int i=0;i<columns;i++)
        		D[i]=pow(stdev[i],2);

        	return D;
    }

    //Last row Outlier remove and replace with mean computed from row-1 rows
    //if no outlier just replace with all rows mean
    double * AvgOutlierFilterQ(double *D);
    double * AvgOutlierFilterQnorm(double *D); //this function only for quaternions as they have to be normalized

    //Just normalize the array of length columns and return it.
    //this function is specifically for quaternions moving avg filter
    double NormVec(double *D){
    	double mag=0;
    	for(int c=0;c<columns;c++){
    		mag=mag+pow(D[c],2);
    	}
    	for(int c=0;c<columns;c++){
    	    		D[c]=D[c]/mag;
    	}

    	return sqrt(mag);
    }

};




 //%%%%%%%%%%%%%%%%%%%%%%%   States used in your estimator/controller   %%%%%%%%%%%%%%%%%%%%%%
struct QuadStateVariable {
	 double t;
	 SimpleQueue tvec;

	 double q[4],w[3],x[3],v[3],a[3],wdot[3],qref[4]; //all the current filtered estimated quantities
	 double w_meas[3],a_meas[3],x_meas[3],q_meas[4]; //stores the history of IMU measurements

	 // raw data with not conditioning or estimation
	 //double Data_w_meas[3][data_queue_length],Data_a_meas[3][data_queue_length],Data_q_meas[4][data_queue_length],Data_x_meas[3][data_queue_length];
	 SimpleQueue Data_w_meas,Data_a_meas,Data_q_meas,Data_x_meas;

	 // filtered data after conditions and estimation
	 //double Data_w_est[3][data_queue_length],Data_a_est[3][data_queue_length],Data_q_est[4][data_queue_length],Data_x_est[3][data_queue_length];
	 //double Data_v_est[3][data_queue_length],Data_wdot_est[3][data_queue_length];
	 SimpleQueue Data_w_est,Data_a_est,Data_q_est,Data_x_est,Data_v_est,Data_wdot_est;


	 double Fd,Fd_prev; //latest force thrust required

	 double ba[3],bg[3],rmis[3],qmis[4];//all the constant est parameters
	 double ba_prev[3],bg_prev[3],rmis_prev[3],qmis_prev[4];//prev good values: used when current values make no sense

	 MatrixXd m(2,2);

};

int CheckVec(double * V,double *Vp,int n,double pu,double pl);


/*
 * Check for physical consistency for all the variables (because sometimes data from serial can be erratic).
*/
void Condition_received_data(QuadStateVariable * data,int threspercent,double Fdnorm);




/*
 *  onboard estimator (1) : ALL estimation is done onboard
 *                          EKF filter
 *                          2 Parallel estimators: Postion + Attitude
 *                          Ground Stattion gets only (x,q)
 */

//position estimation (estimate x,v,a)
// assume you know the current q_est, w_est, wdot_est
struct Estimator1{

double * PropagateMean(double *);


};




#endif
