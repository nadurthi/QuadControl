







#ifndef _KINEMATIC_ESTIMATORS_H_
#define _KINEMATIC_ESTIMATORS_H_



#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <sys/types.h>
#include <fstream>
#include <cmath>
#include "quaternion_operations.h"
#include <algorithm>
using namespace std;

#include "SimpleTimer.h"
#include "MPU6050.h"


#define data_queue_length 10  //no. of time steps of data to remember( so it can be used for simple moving average filters)



SimpleTimer onboardestTimer,viconestTimer;  //usually the onboard timer is also the control update frerquency.





//add the data in D to the matrix T, row wise
void Queue_add(double * D,double T[][data_queue_length],int nrows) {

for(int r=0;r<nrows;r++){
	for(int c=0;c<data_queue_length-1;c++){
		T[r][c]=T[r][c+1];
	}
}
for(int r=0;r<nrows;r++){
	T[r][data_queue_length]=D[r];
}

};


//get the average of the queue T into the array D
void Queue_avg(double * D,double T[][data_queue_length],int nrows) {
	for(int r=0;r<nrows;r++){
		D[r]=0;
		for(int c=0;c<data_queue_length;c++){
			D[r]=D[r]+T[r][c];
		}
	}
}





/*            Explain all the function from where external secondary input is derived
 *            In my case it is the vicon data
 *            Future: Pressure, GPS input and image flow sensors will be included
//#############################################################################################




//**********************************************************************************************
*/


 //%%%%%%%%%%%%%%%%%%%%%%%   States used in your estimator/controller   %%%%%%%%%%%%%%%%%%%%%%
struct QuadStateVariable {
	int t;
	double q[4],w[3],x[3],v[3],a[3],wdot[3]; //all estimated quantities
	 double q_vicon[4],x_vicon[3]; //all vicon quantities
	 double AccGyro[7]; //raw [time,ax,ay,az,gx,gy,gz]
	 double Data_AccGyro[7][data_queue_length]; //stores the history of IMU measurements
	 double Data_XQ[8][data_queue_length];  // stores the history of vicon measurements [time,x,y,z,q0,q1,q2,q3]
     double Fd[3]; //force thrust required
	 double ba[3],bg[3],rmis[3],qmis[4];//all the constant est parameters
};
 //*******************************************************************************************



//initialize the sensors, covariances, biases
// read 100 values from each sensor and take the average
 // do not more the iMU. Let it stay stationary
 //Note: we are removing gravity here too. Not a good bias calculator.
 //Note: We have not even accounted for the misalignment in the sensor direction







// Filter 1:   Onboard attitude estimator : estimates q and w.  (quaternion and body rates)
// Primary input are acc and gyro measurements
// secondary inputs are external vicon x and q. (this comes at a slower rate).
// Additionally the biases can be estimated onboard or on ground station.
// Have to send the imu data back to ground station at the same rate as vicon input.
// REMEMBER: the acc measurements actually measure the gravity force also. so always remove the gravity force to get true acc values

//**************************************** Method 1a: onboard bias correction ******************************************************





//**************************************** Method 1b: use ground station bias correction ******************************************************
//FUTURE: Correct IMU q misalignment wrt to vicon q







//Filter 2: Onboard attitude estimator
// Primary input are acc and gyro measurements
// No secondary vicon input
// biases are to be corrected with onboard imu data itself(perhaps at time 0)
// REMEMBER: the acc measurements actually measure the gravity force also. so always remove the gravity force to get true acc values


















#endif
