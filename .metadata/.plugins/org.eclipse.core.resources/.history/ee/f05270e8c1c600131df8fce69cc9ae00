







#ifndef _KINEMATIC_ESTIMATORS_H_
#define _KINEMATIC_ESTIMATORS_H_



#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <sys/types.h>
#include <fstream>
#include <cmath>
#include "quaternion_operations.h"
#include <algorithm>

using namespace std;



#define data_queue_length 10  //no. of time steps of data to remember( so it can be used for simple moving average filters)




class SimpleQueue {
	double  **a,*stdev,*maxstdev,*mu;
	int rows,columns;

public:
	//dynamically create a Queue and initialize with zeros
	void CreateQ(int rows,int cols){
		this->rows=rows;
		columns=cols;
		// allocation
		 stdev=new double [cols];
		 maxstdev=new double [cols];
		 mu=new double [cols];

			a = new double*[rows];
			for(int i = 0; i < rows; i++)
				a[i] = new double[cols];

			for(int r=0;r<rows;r++){
				for(int c=0;c<cols;c++){
					a[r][c]=0;
					stdev[c]=0;
					maxstdev[c]=0;
				}
			}
	}

	int * GetSizeQ(int *S){
		S[0]=rows;S[1]=columns;
		return S;
	}
    int CheckSizeQ(int r,int c){
    	if((r<rows && r>=0) && (c<columns && c>=0))
    	return 1;
    	else
    	return -1;
    }

	//append always to the last of queue. D has same columns as Q. The ques is shifted up. First element is lost
    //C is array of column numbers of D to be used
    void AppendQ(double *D,int *C);
    // replace the (r-1)th row...as counting starts from 0
    void ReplaceRowQ(int r,double *D);
    void ReplaceLastRowQ(double *D);

    //Operations along the rows. Each Col is independednt. From row r1 to r2
    // rmemeber r1 and r2 are c++ ref not matlab ref. ie.e counting starts from 0 in c++.
    //if u want  from 5th row to 9th row, r1=4,r2=8; rows r1 and r2 are also included in the calculation
    void MeanQ(int r1, int r2) ;
    void StdQ( int r1, int r2) ; // also updates the corresponding mu

    //get the data out
    double * GetRowQ(int r,double *D);
    double * GetColQ(int c,double *D);
    double * GetLastRowQ(double *D);
    double * GetStdQ(double *D){
    	for(int i=0;i<columns;i++)
    		D[i]=stdev[i];

    	return D;
    }
    double * GetVarQ(double *D){
        	for(int i=0;i<columns;i++)
        		D[i]=pow(stdev[i],2);

        	return D;
    }

    //Last row Outlier remove and replace with mean computed from row-1 rows
    //if no outlier just replace with all rows mean
    double * AvgOutlierFilterQ(double *D);
    double * SimpleQueue::AvgOutlierFilterQnorm(double *D); //this function only for quaternions as they have to be normalized

    //Just normalize the array of length columns and return it.
    //this function is specifically for quaternions moving avg filter
    double NormVec(double *D){
    	double mag=0;
    	for(int c=0;c<columns;c++){
    		mag=mag+pow(D[c],2);
    	}
    	for(int c=0;c<columns;c++){
    	    		D[c]=D[c]/mag;
    	}

    	return sqrt(mag);
    }

};




 //%%%%%%%%%%%%%%%%%%%%%%%   States used in your estimator/controller   %%%%%%%%%%%%%%%%%%%%%%
struct QuadStateVariable {
	 double t;
	 SimpleQueue tvec;

	 double q[4],w[3],x[3],v[3],a[3],wdot[3],qref[4]; //all the current filtered estimated quantities
	 double w_meas[3],a_meas[3],x_meas[3],q_meas[4]; //stores the history of IMU measurements

	 // raw data with not conditioning or estimation
	 //double Data_w_meas[3][data_queue_length],Data_a_meas[3][data_queue_length],Data_q_meas[4][data_queue_length],Data_x_meas[3][data_queue_length];
	 SimpleQueue Data_w_meas,Data_a_meas,Data_q_meas,Data_x_meas;

	 // filtered data after conditions and estimation
	 //double Data_w_est[3][data_queue_length],Data_a_est[3][data_queue_length],Data_q_est[4][data_queue_length],Data_x_est[3][data_queue_length];
	 //double Data_v_est[3][data_queue_length],Data_wdot_est[3][data_queue_length];
	 SimpleQueue Data_w_est,Data_a_est,Data_q_est,Data_x_est,Data_v_est,Data_wdot_est;


	 double Fd,Fd_prev; //latest force thrust required

	 double ba[3],bg[3],rmis[3],qmis[4];//all the constant est parameters
	 double ba_prev[3],bg_prev[3],rmis_prev[3],qmis_prev[4];//prev good values: used when current values make no sense

};




/*
 * Check for physical consistency for all the variables (because sometimes data from serial can be erratic).
 */
void Condition_received_data(QuadStateVariable * data,int threspercent,double Fdnorm){
	//checking if received parameter data Fd,ba,bg,rmis,qmis make sense

	double pu,pl;
	pu=(1+threspercent/100);
	pl=(1-threspercent/100);

	//
	if(data->ba[0]>pu*data->ba_prev[0] || data->ba[1]>pu*data->ba_prev[1] || data->ba[3]>pu*data->ba_prev[3] || data->ba[0]<pl*data->ba_prev[0] || data->ba[1]<pl*data->ba_prev[1] || data->ba[3]<pl*data->ba_prev[3] ){
		data->ba[0]=data->ba_prev[0];data->ba[1]=data->ba_prev[1];data->ba[2]=data->ba_prev[2];
		cout<<"Current ba values make no sense"<<endl;
	}
	else{
		data->ba_prev[0]=data->ba[0];data->ba_prev[1]=data->ba[1];data->ba_prev[2]=data->ba[2];
	}


	if(data->bg[0]>pu*data->bg_prev[0] || data->bg[1]>pu*data->bg_prev[1] || data->bg[3]>pu*data->bg_prev[3] || data->bg[0]<pl*data->bg_prev[0] || data->bg[1]<pl*data->bg_prev[1] || data->bg[3]<pl*data->bg_prev[3] ){
			data->bg[0]=data->bg_prev[0];data->bg[1]=data->bg_prev[1];data->bg[2]=data->bg_prev[2];
			cout<<"Current ba values make no sense"<<endl;
	}
	else{
			data->bg_prev[0]=data->bg[0];data->bg_prev[1]=data->bg[1];data->bg_prev[2]=data->bg[2];
		}

    //___________________________________

	if(data->Fd>Fdnorm){
		data->Fd=data->Fd_prev;
		cout<<"Current Fd values is not compatible using previous Fd"<<endl;

	}
	else
		data->Fd_prev=data->Fd;

	//____________________________________
	if(CheckVec(data->rmis,data->rmis_prev,3,pu,pl)<0){
		data->rmis[0]=data->rmis_prev[0];data->rmis[1]=data->rmis_prev[1];data->rmis[2]=data->rmis_prev[2];
		cout<<"Current rmis values make no sense"<<endl;
	}
	else{
				data->rmis_prev[0]=data->rmis[0];data->rmis_prev[1]=data->rmis[1];data->rmis_prev[2]=data->rmis[2];
	}


	//____________________________________
	double qq[]={1,1,1,1};
		if(CheckVec(data->qmis,qq,4,1,-1)<0){
			data->qmis[0]=data->qmis_prev[0];data->qmis[1]=data->qmis_prev[1];data->qmis[2]=data->qmis_prev[2];
			cout<<"Current qmis values make no sense"<<endl;
		}
		else{
					data->qmis_prev[0]=data->qmis[0];data->qmis_prev[1]=data->qmis[1];data->qmis_prev[2]=data->qmis[2];
		}



	}

int CheckVec(double * V,double *Vp,int n,double pu,double pl){

	for(int i=0;i<n;i++){
	if(V[i]>pu*Vp[i] || V[i]<pl*Vp[i])
			return -1;
	}
return 1;
}



/*
 *  onboard estimator (1) : ALL estimation is done onboard
 *                          EKF filter
 *                          2 Parallel estimators: Postion + Attitude
 *                          Ground Stattion gets only (x,q)
 */

//position estimation (estimate x,v,a)
// assume you know the current q_est, w_est, wdot_est
struct Estimator1{
double * PropagateMean(double *){

}

};




#endif
